<!DOCTYPE html>
<html>
  <head>
    <title>IE Touch Test - Fixed with setPointerCapture</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" />
    <style>
    blockquote { border-left: 5px #eee solid; padding-left: 1em;}

    div {
      position: absolute;
      top: 60px;
      left: 60px;
      width: 60px;
      height: 60px;
      line-height: 60px;
      overflow: hidden;
      background-color: #000;
      color: #FFF;
      text-align: center;
      touch-action: none; /* more appropriate here rather than on the whole html - but superfluous as there's no default touch action on a div anyway... */
    }
    </style>
    <script>
    this.onload = function () {
      var
        handler = {
          handleEvent: function (e) {
            var et = e.type;
            /* hacky, but as Andrea also wants it to work in vendor-prefixed IE10... */
            if (et == 'pointerdown') { et = 'MSPointerDown'; }
            if (et == 'pointermove') { et = 'MSPointerMove'; }
            if (et == 'pointerup') { et = 'MSPointerUp'; }
            if (et == 'pointercancel') { et = 'MSPointerCancel'; }
            this[et](e);
          },
          MSPointerDown: function (e) {
            if (e.pointerType == 'touch') {
              var div = e.currentTarget;
              if (div.setPointerCapture) { div.setPointerCapture(e.pointerId); }  else if (div.msSetPointerCapture) { div.msSetPointerCapture(e.pointerId); }
              e.currentTarget.textContent = 'start';
              this.diffY = e.pageY - parseFloat(div.style.top || 60);
              this.diffX = e.pageX - parseFloat(div.style.left || 60);
            }
          },
          MSPointerMove: function (e) {
            if (e.pointerType == 'touch') {
              var div = e.currentTarget;
              e.preventDefault();
              div.textContent = 'move';
              div.style.top = (e.pageY - this.diffY) + 'px';
              div.style.left = (e.pageX - this.diffX) + 'px';
            }
          },
          MSPointerUp: function (e) {
            if (e.pointerType == 'touch') {
              e.preventDefault();
              e.currentTarget.textContent = 'end';
            }
          },
          MSpointercancel: function (e) {
            if (e.pointerType == 'touch') {
              e.preventDefault();
              e.currentTarget.textContent = 'cancel';
            }
          }
        }
      ;
      Object.keys(handler).forEach(function (key) {
        this.addEventListener(key, handler);
      }, document.querySelector('div'));
    };
    </script>
  </head>
  <body>
  <h1>I dare you!</h1>
  <blockquote><p>Check the source code of the <a href="http://webreflection.github.io/ie-touch/">basic test</a> and try to replicate the same behavior with your PointerEvents logic and in a cross Mobile browser way ... I dare you!</p><p>After you failed trying to do so...</p></blockquote>
  <p>Actually...it seems that the main problem Andrea was seeing here (in his strangely confrontational <a href="http://webreflection.blogspot.co.uk/2014/05/touch-events-for-ie-mobile.html">Touch Events for IE Mobile</a> rant) would be fixed by appropriate use of <code>setPointerCapture</code> - remember, touch events have an implicit capture model, while pointer events have an explicit capture model.</p>
  <p>As for the "in a cross Mobile browser way" you'd also reintroduce the touch events handlers he has in his original test (omitted here for clarity, but apart from duplication - which is unsurprising, as we're talking about a different event model altogether - this would not have any impact on the code).</p>
  <div></div></body>
</html>